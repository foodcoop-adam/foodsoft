- cur_has_stock = order_article.order.stockit?
- cur_has_tolerance = (order_article.price.unit_quantity > 1)
- group_order_article = order_article.group_order_articles.includes(:group_order).where(group_orders: {ordergroup_id: @current_user.ordergroup.id}).first
- group_order_article ||= GroupOrderArticle.new(quantity: 0, tolerance: 0, order_article: order_article)
%tr{class: "#{cycle('even', 'odd', name: 'order_articles')} order-article"}
  %td.name= order_article.article.name
  %td= order_article.article.origin
  %td= number_to_currency(order_article.price.fc_price)
  %td= order_article.article.unit
  - if @has_stock
    %td= order_article.article.quantity_available if cur_has_stock
  - if @has_tolerance
    %td{id: "missing_units_#{order_article.id}"}= order_article.missing_units if cur_has_tolerance
  %td.center.quantity
    = simple_fields_for "group_order[group_order_articles_attributes][#{order_article.id}]", group_order_article do |f|
      - data_delta = {min: 0, granularity: 1}.merge(cur_has_stock ? {max: order_article.article.quantity_available} : {})
      = f.input_field :quantity, as: :delta, class: 'input-nano', data: data_delta, id: "q_#{order_article.id}"
  - if @has_tolerance
    %td.center.tolerance
      = simple_fields_for "group_order[group_order_articles_attributes][#{order_article.id}]", group_order_article do |f|
        - if cur_has_tolerance
          - data_delta = {min: 0, granularity: 1, max: order_article.price.unit_quantity-1}
          = f.input_field :tolerance, as: :delta, class: 'input-nano', data: data_delta, id: "t_#{order_article.id}"
  %td{id: "td_price_#{order_article.id}"}
    %span{id: "price_#{order_article.id}_display"}= number_to_currency((group_order_article.total_price))
    = render 'order_article_info', order_article: order_article
